# Function

A **function** in Python is a group of related statements that perform a specific task. Functions help break down a program into smaller, **modular sections**. As a program grows larger and more complex, functions make it more organized and **manageable**. Furthermore, functions **prevent code repetition** for a single task and make the code **reusable**. Advantages of function are as follow:

1. **Organization and Manageability**: Instead of a long script, your code becomes a **collection of small, understandable functions**. Each function has a name that describes what it does (e.g., calculate_total, validate_results, print_report). This makes the program's logic much **easier to follow, debug, and modify**. As your project grows, this structure becomes indispensable.
  
2. **Elimination of Repetition (DRY Principle)**: The DRY principle stands for "**Don't Repeat Yourself**." If you find yourself writing the same code in multiple places, that's a sign you need a function. You **write the code once inside the function**, and **then you can call that function from anywhere in your program** whenever you need that task performed. This **not only saves time but also prevents errors**. If you need to **change the logic**, you only have to update it in one place.
   
3. **Reusability**: **Once a function is written and tested, it becomes a reusable building block**. You can use it in the **same program**, or even copy it into an entirely **different project**, **saving development time and effort**. This is why **Python has a rich ecosystem of libraries and modules** they are essentially collections of pre-written, reusable functions.

4. **Abstraction**: A function allows you to use **code without needing to understand its internal complexities**. For example, you can use Python's built-in **`sort()`** function without knowing which sorting algorithm it uses. **You only need to know what data to give it (the input) and what result to expect back (the output)**. This allows you to build **complex programs by combining simpler, abstracted parts**.

Python has **two types of functions**:
1. Built-in Functions
2. User-Defined Functions

## Built-in Functions
These are functions that come **predefined in Python**, ready for you to use without writing any additional code. Examples of common built-in functions:

| Function  | Description                  | Example                        |
| --------- | ---------------------------- | ------------------------------ |
| `print()` | Displays output              | `print("Hello")`               |
| `len()`   | Gives length of a sequence   | `len("Python")`                |
| `type()`  | Shows the type of a variable | `type(5)`                      |
| `int()`   | Converts to integer          | `int("10")`                    |
| `str()`   | Converts to string           | `str(123)`                     |
| `float()` | Converts to float            | `float("3.14")`                |
| `input()` | Takes input from user        | `name = input("Enter name: ")` |
| `max()`   | Returns the largest value    | `max(2, 5, 1)`                 |
| `min()`   | Returns the smallest value   | `min(2, 5, 1)`                 |


**Example**

```python
   x = len([10, 20, 30])
   print(x)   # Output: 3
```

## User-Defined Functions
These are functions that **you create yourself** to perform a specific task. Python function is defined by the following rules:
1. The `def` keyword is the marker that begins a function's header.
2. Then define function name (`function_name`), which must **uniquely identify the function**.
3. The naming of functions in Python follows the same rules as those for **naming identifiers**.

**docstring**
1. An **optional docstring** (documentation string) is used to **describe what the function does**.
2. Although using a docstring is optional, **documentation is considered a crucial practice** in programming.
3. The docstring is enclosed within triple quotes (`'''` or `"""`).

**Body of a function**
1. **One or more Python statements** form the body of the function.
2. The statements must all be at the **same indentation level** (**typically 4 spaces**).
3. An **optional return statement** is used to **send a value back** from the function.

**The values a Python function returns:**
1. It may return **no value**.
2. It may return a **single value**.
3. It may return **multiple values**.

**Syntax**

```python
    """ Your docstring. """
    def function_name(parameters):
        # code block
        return value
```

**Simple Example**

```python
    """ This function is a simple greeting function. """
    def greet():
        print("Hello, welcome to Python!")
```

**Calling the function:**
1. After a function is defined, it can be called from within another function, the main program, or even the Python command prompt.
2. To call a function in Python, you simply write its name followed by the appropriate parameters: `function_name(parameters)`
3. The number of arguments in the function call must match the number of parameters in the function's definition.
4. Python also allows a function to be called from within another function.

```python
    greet()
    # Output: Hello, welcome to Python!
```

### Functions with Required Parameters (arguments)
You can pass values to functions using parameters.
1. Parameters (or arguments) are used to **pass values into a function**. They are optional.
2. Function parameters are separated from each other by commas (`,`).
3. When the function is called, values for these parameters must be provided to it.
4. A colon (`:`) marks the end of the function header.

**In Python, when calling a function, you can pass arguments in two ways:**
1. **Positional arguments**: these must be **passed to the function during the call in the exact same order and quantity** as they are defined in the function. 
2. **Keyword arguments**: python allows functions to be called **using keyword arguments**. When functions are called in this manner, **the order of the arguments can be changed.**
   * ✔ Clear
   * ✔ Easy to understand
   * ✔ Order does not matter
     
3. **Order of Arguments**
   * ✅ Positional arguments must always come first.
   * ❌ Having a positional argument after a keyword argument will result in an error.

   **Correct Example**
   ```python
      def info(name, age, city):
          print(name, age, city)
      
      info("Ali", age=20, city="Baku")   # Valid
   ```

   * "Ali" → positional argument
   * age=20, city="Tehran" → keyword arguments

   **Incorrect Example (Error)**
   ```python
      info(age=20, "Ali", city="Baku")
      # Output: SyntaxError: positional argument follows keyword argument   
   ```



### Calling functions with positional arguments

  **Example**
  
  ```python
    def student_info(name, age, grade):
        print("Name:", name)
        print("Age:", age)
        print("Grade:", grade)
    
    # Calling with keyword arguments
    student_info("Ali", 15, "A")
  ```

  **Output**

  ```
  Name: Ali
  Age: 15
  Grade: A
  ```

### Calling functions with keyword arguments
   
  **Example**
  
  ```python
    def student_info(name, age, grade):
        print("Name:", name)
        print("Age:", age)
        print("Grade:", grade)
    
    # Calling with keyword arguments
    student_info(age=15, name="Ali", grade="A")
  ```

  **Output**

  ```
  Name: Ali
  Age: 15
  Grade: A
  ```

### Functions with Default Parameters
You can set default values for parameters. You can assign a default value to an argument using the assignment operator (`=`) in the function definition.

**Example**

```python
   def greet(name="User"):
      print("Hello,", name)
  
   greet()         # uses default
   greet("Majid")  # overrides default
```

**Output**

```
Hello, User
Hello, Majid
```

### Functions Returning Multiple Values
Python can return more than one value using tuples.

**Example**

```python
   def calculate(a, b):
       return a + b, a * b

   sum_result, mul_result = calculate(3, 4)
   print(sum_result, mul_result)             # Output 7 12
```

The general structure of functions are as follow:

<img width="396" height="385" alt="image" src="https://github.com/user-attachments/assets/757d4de8-378d-42ae-a15c-179c1eafa9aa" />

### Python Keyword Arguments
1. When a function is called with multiple values, these values are assigned to the arguments based on their position.
2. Python allows functions to be **called using keyword arguments**. When functions are called in this manner, **the order of the arguments can be changed**.

# Scope of Variables in Python
1. In Python, the **scope of a variable** refers to the **part of a program where the variable is recognized**.
2. Parameters and variables defined inside a function are not accessible from outside that function.
3. The **lifetime of a variable** inside a function lasts only for the duration of the function's execution. Variables within a function are destroyed after the function returns.
4. There are **two main types of scopes** you need to know:
   * Local Variable
   * Global Variable

## Local Variables
A local variable is a variable that is **created inside a function** and can only be used **inside that function**.
* It exists only **while the function is running**
* It **cannot be accessed outside the function**

**Example: Local Variable**

```python
    def my_function():
        x = 10  # local variable
        print("Inside function:", x)
    
    my_function()    # Inside function: 10
    
    print(x)  # ❌ Error: x is not defined
```

## Global Variables
A global variable is **created outside any function**, and it can be **accessed from anywhere** in the program.
* Functions can read global variables
* To **modify a global variable** inside a function, you must use the **global keyword**

**Example: Global Variable**

```python
    x = 10  # global variable
    
    def my_function():
        print("Inside function:", x)
    
    my_function()
    print("Outside function:", x)
```

**Output**

```
Inside function: 10
Outside function: 10
```

### Modifying a Global Variable Inside a Function
If you **try to change a global variable** inside a function **without declaring it global**, Python **creates a new local variable** instead.

**Wrong way (creates local variable)**

```python
    x = 10
    
    def my_function():
        x = 5  # This becomes LOCAL, does not change global x
        print("Inside function:", x)
    
    my_function()
    print("Outside function:", x)  # Still 10
```

**Output**

```
Inside function: 5
Outside function: 10
```

**Correct way using `global`**

```python
    x = 10
    
    def my_function():
        global x
        x = 5  # modifies global x
        print("Inside function:", x)
    
    my_function()
    print("Outside function:", x)  # Now it’s 5
```

**Output**

```
Inside function: 5
Outside function: 5
```

**Summary Table**

| Type of Variable | Defined Where?    | Accessible Where?         | Lifetime                  |
| ---------------- | ----------------- | ------------------------- | ------------------------- |
| **Local**        | Inside function   | Only inside that function | While function is running |
| **Global**       | Outside functions | Anywhere in program       | Until program ends        |

