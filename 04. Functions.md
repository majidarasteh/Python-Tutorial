# Function

A **function** in Python is a group of related statements that perform a specific task. Functions help break down a program into smaller, **modular sections**. As a program grows larger and more complex, functions make it more organized and **manageable**. Furthermore, functions **prevent code repetition** for a single task and make the code **reusable**. Advantages of function are as follow:

1. **Organization and Manageability**: Instead of a long script, your code becomes a **collection of small, understandable functions**. Each function has a name that describes what it does (e.g., calculate_total, validate_results, print_report). This makes the program's logic much **easier to follow, debug, and modify**. As your project grows, this structure becomes indispensable.
  
2. **Elimination of Repetition (DRY Principle)**: The DRY principle stands for "**Don't Repeat Yourself**." If you find yourself writing the same code in multiple places, that's a sign you need a function. You **write the code once inside the function**, and **then you can call that function from anywhere in your program** whenever you need that task performed. This **not only saves time but also prevents errors**. If you need to **change the logic**, you only have to update it in one place.
   
3. **Reusability**: **Once a function is written and tested, it becomes a reusable building block**. You can use it in the **same program**, or even copy it into an entirely **different project**, **saving development time and effort**. This is why **Python has a rich ecosystem of libraries and modules** they are essentially collections of pre-written, reusable functions.

4. **Abstraction**: A function allows you to use **code without needing to understand its internal complexities**. For example, you can use Python's built-in **`sort()`** function without knowing which sorting algorithm it uses. **You only need to know what data to give it (the input) and what result to expect back (the output)**. This allows you to build **complex programs by combining simpler, abstracted parts**.

Python has **two types of functions**:
1. Built-in Functions
2. User-Defined Functions

## Built-in Functions
These are functions that come **predefined in Python**, ready for you to use without writing any additional code. Examples of common built-in functions:

| Function  | Description                  | Example                        |
| --------- | ---------------------------- | ------------------------------ |
| `print()` | Displays output              | `print("Hello")`               |
| `len()`   | Gives length of a sequence   | `len("Python")`                |
| `type()`  | Shows the type of a variable | `type(5)`                      |
| `int()`   | Converts to integer          | `int("10")`                    |
| `str()`   | Converts to string           | `str(123)`                     |
| `float()` | Converts to float            | `float("3.14")`                |
| `input()` | Takes input from user        | `name = input("Enter name: ")` |
| `max()`   | Returns the largest value    | `max(2, 5, 1)`                 |
| `min()`   | Returns the smallest value   | `min(2, 5, 1)`                 |


**Example**

```python
   x = len([10, 20, 30])
   print(x)   # Output: 3
```

## User-Defined Functions
These are functions that **you create yourself** to perform a specific task. Python function is defined by the following rules:
1. The `def` keyword is the marker that begins a function's header.
2. Then define function name (`function_name`), which must **uniquely identify the function**.
3. The naming of functions in Python follows the same rules as those for **naming identifiers**.

**docstring**
1. An **optional docstring** (documentation string) is used to **describe what the function does**.
2. Although using a docstring is optional, **documentation is considered a crucial practice** in programming.
3. The docstring is enclosed within triple quotes (`'''` or `"""`).

**Body of a function**
1. **One or more Python statements** form the body of the function.
2. The statements must all be at the **same indentation level** (**typically 4 spaces**).
3. An **optional return statement** is used to **send a value back** from the function.

**The values a Python function returns:**
1. It may return **no value**.
2. It may return a **single value**.
3. It may return **multiple values**.

**Syntax**

```python
    """ Your docstring. """
    def function_name(parameters):
        # code block
        return value
```

**Simple Example**

```python
    """ This function is a simple greeting function. """
    def greet():
        print("Hello, welcome to Python!")
```

**Calling the function:**
1. After a function is defined, it can be called from within another function, the main program, or even the Python command prompt.
2. To call a function in Python, you simply write its name followed by the appropriate parameters: `function_name(parameters)`
3. The number of arguments in the function call must match the number of parameters in the function's definition.
4. Python also allows a function to be called from within another function.

```python
    greet()
    # Output: Hello, welcome to Python!
```

**The general structure of functions are as follow:**

<img width="396" height="385" alt="image" src="https://github.com/user-attachments/assets/757d4de8-378d-42ae-a15c-179c1eafa9aa" />

## Functions with Required Parameters (arguments)
You can pass values to functions using parameters.
1. Parameters (or arguments) are used to **pass values into a function**. They are optional.
2. Function parameters are separated from each other by commas (`,`).
3. When the function is called, values for these parameters must be provided to it.
4. A colon (`:`) marks the end of the function header.

**In Python, when calling a function, you can pass arguments in two ways:**
1. **Positional arguments**: these must be **passed to the function during the call in the exact same order and quantity** as they are defined in the function. 
2. **Keyword arguments**: python allows functions to be called **using keyword arguments**. When functions are called in this manner, **the order of the arguments can be changed.**
   * ✔ Clear
   * ✔ Easy to understand
   * ✔ Order does not matter
     
* **Order of Arguments**
   * ✅ Positional arguments must always come first.
   * ❌ Having a positional argument after a keyword argument will result in an error.

   **Correct Example**
   ```python
      def info(name, age, city):
          print(name, age, city)
      
      info("Ali", age=20, city="Baku")   # Valid
   ```

   * "Ali" → positional argument
   * age=20, city="Tehran" → keyword arguments

   **Incorrect Example (Error)**
   ```python
      info(age=20, "Ali", city="Baku")
      # Output: SyntaxError: positional argument follows keyword argument   
   ```

### Calling functions with positional arguments

  **Example**
  
  ```python
    def student_info(name, age, grade):
        print("Name:", name)
        print("Age:", age)
        print("Grade:", grade)
    
    # Calling with keyword arguments
    student_info("Ali", 15, "A")
  ```

  **Output**

  ```
  Name: Ali
  Age: 15
  Grade: A
  ```

### Calling functions with keyword arguments
   
  **Example**
  
  ```python
    def student_info(name, age, grade):
        print("Name:", name)
        print("Age:", age)
        print("Grade:", grade)
    
    # Calling with keyword arguments
    student_info(age=15, name="Ali", grade="A")
  ```

  **Output**

  ```
  Name: Ali
  Age: 15
  Grade: A
  ```

### Functions with Default Parameters
You can set default values for parameters. You can assign a default value to an argument using the assignment operator (`=`) in the function definition.

**Example**

```python
   def greet(name="User"):
      print("Hello,", name)
  
   greet()         # uses default
   greet("Majid")  # overrides default
```

**Output**

```
Hello, User
Hello, Majid
```

### Functions Returning Multiple Values
Python can return more than one value using tuples.

**Example**

```python
   def calculate(a, b):
       return a + b, a * b

   sum_result, mul_result = calculate(3, 4)
   print(sum_result, mul_result)             # Output 7 12
```

### Using `*args` for Variable-Length Positional Arguments
`*args` allows you to **pass any number of positional arguments** to a function.
1. `*` tells Python to collect all extra positional arguments
2. **args becomes a tuple** containing those values

**Example**

```python
  def sum_numbers(*numbers):
      total = 0
      for n in numbers:
          total += n
      print("Total:", total)
  
  sum_numbers(3, 5)
  sum_numbers(1, 2, 3, 4, 5)
```

**Output**
```
Total: 8
Total: 15
```

# Scope of Variables in Python
1. In Python, the **scope of a variable** refers to the **part of a program where the variable is recognized**.
2. Parameters and variables defined inside a function are not accessible from outside that function.
3. The **lifetime of a variable** inside a function lasts only for the duration of the function's execution. Variables within a function are destroyed after the function returns.
4. There are **two main types of scopes** you need to know:
   * Local Variable
   * Global Variable

## Local Variables
A local variable is a variable that is **created inside a function** and can only be used **inside that function**.
* It exists only **while the function is running**
* It **cannot be accessed outside the function**

**Example: Local Variable**

```python
    def my_function():
        x = 10  # local variable
        print("Inside function:", x)
    
    my_function()    # Inside function: 10
    
    print(x)  # ❌ Error: x is not defined
```

## Global Variables
A global variable is **created outside any function**, and it can be **accessed from anywhere** in the program.
* Functions can read global variables
* To **modify a global variable** inside a function, you must use the **global keyword**

**Example: Global Variable**

```python
    x = 10  # global variable
    
    def my_function():
        print("Inside function:", x)
    
    my_function()
    print("Outside function:", x)
```

**Output**

```
Inside function: 10
Outside function: 10
```

### Modifying a Global Variable Inside a Function
If you **try to change a global variable** inside a function **without declaring it global**, Python **creates a new local variable** instead.

**Wrong way (creates local variable)**

```python
    x = 10
    
    def my_function():
        x = 5  # This becomes LOCAL, does not change global x
        print("Inside function:", x)
    
    my_function()
    print("Outside function:", x)  # Still 10
```

**Output**

```
Inside function: 5
Outside function: 10
```

**Correct way using `global`**

```python
    x = 10
    
    def my_function():
        global x
        x = 5  # modifies global x
        print("Inside function:", x)
    
    my_function()
    print("Outside function:", x)  # Now it’s 5
```

**Output**

```
Inside function: 5
Outside function: 5
```

**Summary Table**

| Type of Variable | Defined Where?    | Accessible Where?         | Lifetime                  |
| ---------------- | ----------------- | ------------------------- | ------------------------- |
| **Local**        | Inside function   | Only inside that function | While function is running |
| **Global**       | Outside functions | Anywhere in program       | Until program ends        |


# Lambda Functions in Python
So far, the functions we've discussed are defined with the `def` keyword. These are named functions with a specific block of code. A **lambda function** is a **small, anonymous** function defined using the keyword `lambda`. It is often used when we need a simple function for a short time.
1. You cannot call other functions within a lambda's body.
2. Lambda functions have their **own local namespace** and cannot access variables from the enclosing scope in a global manner.
3. Lambda functions are **not designed for recursive operations**.

**Syntax**

```python
    lambda arguments: expression
```

**First example**

```python
    square = lambda x: x * x
    print(square(5))   # Output: 25
```

**Second example**

```python
    add_numbers = lambda number1, number2: number1 + number2
    print(add_numbers(number1=4, number2=3))                  # Output: 7
```
Lambda functions are commonly used with `map()` and `filter()`.

## `map()` Function
`map()` applies a function to **each element of an iterable (list, tuple, etc.)** and returns a **new map object** (which can be converted to a list).

**Syntax**

```python
    map(function, iterable)
```

**Example: Using `lambda` with `map()`**

```python
    numbers = [1, 2, 3, 4, 5]
    
    squared = list(map(lambda x: x * x, numbers))
    print(squared)
```

**Output**

```
    [1, 4, 9, 16, 25]
```

**Example: Convert temperatures from Celsius to Fahrenheit**

```python
    celsius = [0, 10, 20, 30]
    
    fahrenheit = list(map(lambda c: c * 9/5 + 32, celsius))
    print(fahrenheit)
    # Output: [32.0, 50.0, 68.0, 86.0]
```

**Example**

```python
    numbers1 = [1, 2, 3]
    numbers2 = [4, 5, 6]
    
    result = list(map(lambda x, y: x + y, numbers1, numbers2))
    print(result)   # [5, 7, 9]
```

## `filter()` Function

`filter()` **filters the elements of an iterable** using a function that returns True or False.

**Syntax**

```python
    filter(function, iterable)
```

**Example: Using `lambda` with `filter()`**

```python
    numbers = [1, 2, 3, 4, 5, 6]
    
    evens = list(filter(lambda x: x % 2 == 0, numbers))
    print(evens)
```

**Output**

```
    [2, 4, 6]
```

**Example: Filter names longer than 3 characters**

```python
    names = ["Ali", "Sara", "Reza", "Tom"]
    
    long_names = list(filter(lambda n: len(n) > 3, names))
    print(long_names)
```

**Output**

```
    ['Sara', 'Reza']
```

## `reduce` Function
Here are simple, clear examples of `reduce()` with lambda:

**Example: Using `reduce` + `lambda` to sum numbers**

```python
    from functools import reduce
    
    numbers = [1, 2, 3, 4, 5]
    
    result = reduce(lambda x, y: x + y, numbers)
    print(result)   # Output: 15
```

**Example: Using `reduce` + `lambda` to the product numbers**

```python
    from functools import reduce
    
    numbers = [1, 2, 3, 4]
    
    result = reduce(lambda x, y: x * y, numbers)
    print(result)   # Output: 24
```

**Example: Using `reduce` + `lambda` to the find maximum number**

```python
    from functools import reduce
    
    numbers = [12, 7, 25, 3, 18]
    
    max_value = reduce(lambda x, y: x if x > y else y, numbers)
    print(max_value)   # Output: 25
```

**Example: Using `reduce` + `lambda` to join strings**

```python
    from functools import reduce
    
    words = ["Python", "is", "fun"]
    
    sentence = reduce(lambda x, y: x + " " + y, words)
    print(sentence)   # Output: Python is fun
```

## Combine `map` + `filter` + `reduce` together, using `lambda
Here are clear and practical examples that combine **map + filter + reduce together, using lambda** functions.

```python
    from functools import reduce
    
    numbers = [1, 2, 3, 4, 5, 6]
    
    result = reduce(
        lambda a, b: a + b,
        map(
            lambda x: x * x,
            filter(lambda x: x % 2 == 0, numbers)
        )
    )
    
    print(result)   # 56   (2² + 4² + 6² = 4 + 16 + 36)
```

**Example 2: Multiply all numbers greater than 3**

```python
    from functools import reduce
    
    numbers = [1, 2, 3, 4, 5, 6]
    
    result = reduce(
        lambda a, b: a * b,
        map(
            lambda x: x * 2,
            filter(lambda x: x > 3, numbers)
        )
    )
    
    print(result)  # (8 * 10 * 12) = 960
```

# Recursive Functions in Python

A **recursive function** is a function that **calls itself** to solve a smaller part of the same problem.

1. **Advantages of Recursive Functions**
   * They result in clean and organized code, helping to **avoid long sequences of nested loops**.
   * A **complex task can be broken down into smaller sub-problems using recursion**, which often aligns naturally with the problem's structure.

2. **Disadvantages of Recursive Functions**
   * Recursive function calls can be **computationally expensive (inefficient)** as they consume significant memory and time due to repeated function calls.
   * Sometimes the **logic can be difficult to follow**, and **debugging recursive functions can be challenging**.

**Important Notes About Recursio**
1. Always define a **base case**.
2. **Deep recursion** may cause `RecursionError` in Python.
3. **Sometimes loops are faster**, but **recursion makes code cleaner** for many problems.

**Example 1: Factorial Calculation**

```
    5! = 5 × 4 × 3 × 2 × 1
```

**Code**

```python
    def factorial(n):
        if n == 1:          # Base case
            return 1
        return n * factorial(n - 1)   # Recursive case
    
    print(factorial(5))
    # Output 120
```

**Example 2: Sum of Numbers From 1 to n**

```python
    def recursive_sum(n):
        if n == 0:      # Base case
            return 0
        return n + recursive_sum(n - 1)
    
    print(recursive_sum(5))
    # Output 15
```

**Example 3: Fibonacci Sequence**

```
Fibonacci numbers:
0, 1, 1, 2, 3, 5, 8, 13...
```

```python
    def fib(n):
        if n <= 1:      # Base cases
            return n
        return fib(n - 1) + fib(n - 2)
    
    print(fib(6))
    # Output 8
```
