# **1. Introduction to Object-Oriented Programming in Python**
This section explains the concept of **object-oriented programming (OOP)** and how Python supports it. Object-Oriented Programming (OOP) models real-world objects such as animals, cars, users, bank accounts, etc.

Python is considered an object-oriented programming language because everything is treated as an **object** (integers, strings, lists, tuples, sets, functions, classes). Advantages of OOP:

* Better organization of code
* Encapsulation
* Reusability
* Ability to group attributes and behavior together

---

# **2. Objects in Python**

**Description:**
An object is a concrete **instance of a class**. Objects have:

* **Properties (Attributes - state):** Data such as color, weight, size
* **Methods (Behaviors):** Operations such as walk(), fly(), deposit(), etc.

Example (conceptual):

* Object name: *bird*
* Attributes: *color, weight*
* Behavior: *Walking, flying, drinking, eating*

You can check the type of any object using `type()`. Also, `isinstance()` checks membership in a class hierarchy.
* `type(x)`: returns the class/type of `x`.
* `isinstance(obj, Class)` — returns `True` if `obj` is instance of `Class` or its `subclasses`.

---

# **3. Classes in Python**

**Description:**
A class is a blueprint for objects: it **declares attributes (data fields) and methods (operations)**. Classes **group related data and behavior**, making code modular and easier to reason about.

**Example (conceptual):**

* Class: Car
* Properties: Doors, wheels, color
* Methods: Start, stop, brake

**A class describes:**

* Attributes (data members)
* Methods (behaviors)
* Constructor, destructor
* Static/dynamic features

---

# **4. Defining Classes**

Use `class` followed by a capitalized identifier. Provide a docstring for clarity. Inside the class you declare attributes and methods.

### Example: Basic Class Definition

```python
class MyClass:
    """This is a simple class"""
```

---

# **5. Instantiating Classes**

Creating an object (instantiation) **runs the** `__init__` **constructor** and **returns an instance** you can use.

### Example: Creating an Instance

```python
class Shape:
    shape1 = "Circle"
    Pi = 3.14

shp = Shape()
print(shp.shape1)
```

### **Output**

```
Circle
```

---

# **6. Accessing Class Members**

How to access attributes inside and outside a class.

* Outside (instance property access): `obj.attribute`
* Outside (static attribute - class-level access): `ClassName.attribute`
* Inside class: `self.attribute`

---

# **7. Fields and Methods (Attributes and Behaviors)**

* **Fields (attributes):** store object data; can be public, protected, or private by naming convention.
* **Methods**: functions defined in the `class`; **first parameter is** `self` (the instance).

---

# **8. Example: Circle Class**

Shows basic class with methods and `__str__`. The `__str__` is for printable representation and should return a human-readable string.

### Code:

```python
import math

class Circle:
    pi = math.pi
    r = 0

    def Area(self):     # Returns area of circle
        return self.pi * self.r ** 2

    def Perime(self):   # Returns perimeter of circle
        return 2 * self.pi * self.r

    def __str__(self):  # Converts object to string
        s = "R is:" + str(self.r)
        s += " Area is:" + str(self.Area())
        s += " Perime is:" + str(self.Perime())
        return s

c = Circle()
c.r = 3
print(c)
```

### Output:

```
R is:3 Area is:28.274333882308138 Perime is:18.84955592153876
```

---

# **9. Constructor (**init**)**

**Description:**
Initializes object attributes when object is created.

### Code:

```python
class Circle:
    pi = 3.14

    def __init__(self, r):   # Constructor: initializes radius
        self.r = r

    def Area(self):
        return self.pi * self.r ** 2
```

### Example:

```python
c = Circle(5)
print(c.Area())
```

### Output:

```
78.5
```

---

# **10. Destructor (**del**)**

The destructor is a special method that **gets called when an object is about to be destroyed**. It's used for cleanup operations before the object is removed from memory.

### Code:

```python
class Test:
    def __del__(self):   # Destructor: runs on delete
        print("Object destroyed")

obj = Test()
del obj
```

### Output:

```
Object destroyed
```

---

# **11. Dynamic vs Static Methods**

**Description:**

* **Static method**: Methods that don't have access to the instance or class. Does not use `self`. Behave like regular functions but belong to the class namespace.
* **Dynamic method**: Regular methods that belong to object instances. Uses `self`.

### Code:

```python
class Person:

    @staticmethod
    def display():       # Static method: prints welcome
        print("Welcome!!")

    @staticmethod
    def func1(n):        # Static method: prints square
        print(n * n)

Person.display()
Person.func1(5)
```

### Output:

```
Welcome!!
25
```

---

# **12. Encapsulation**

Encapsulation restricts direct access to attributes and methods.

**Types of access**:

* **Public**: Accessible from anywhere, default in Python, and No special syntax.
* **Private** (`__name`): Accessible only within the class, and name mangling with **double underscore prefix**.
* **Protected** (`_name`): Accessible within the class and its subclasses and  name mangling with with **single underscore prefix**.

---

# **13. Public Members**

### Code:

```python
class Employee:
    def __init__(self, name, age):
        self.name = name      # Public
        self.age = age        # Public

    def display(self):
        print("Employee Name:", self.name)
        print("Employee Age:", self.age)

s = Employee("Ali", 20)
s.display()
```

### Output:

```
Employee Name: Ali
Employee Age: 20
```

---

# **14. Private Members**

**Description:**
Private attributes are accessed only inside the class.

### Code:

```python
class BankAccount:
    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance  # Private

    def deposit(self, amount):
        self.__balance += amount
        print("New balance:", self.__balance)

acc = BankAccount("John", 1000)
acc.deposit(500)
```

### Output:

```
New balance: 1500
```

---

# **15. Getters and Setters**

**Description:**
Allows controlled read/write access to private attributes.

### Code:

```python
class Student:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def get_name(self):     # Getter
        return self.__name

    def set_name(self, name):  # Setter
        self.__name = name

student = Student("Alice", 20)
print(student.get_name())
student.set_name("Bob")
print(student.get_name())
```

### Output:

```
Alice
Bob
```

---

# **16. Name Mangling**
**Name Mangling** allows an object to access private attributes of a class from outside the class by using a specific naming pattern. Name mangling violates encapsulation principles and should be used restrictly.

**Access Pattern:**

```python
object_name._ClassName__private_attribute
```

### Code:

```python
class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.__salary = salary

emp = Employee("Jessa", 10000)
print(emp._Employee__salary)   # Mangled access
```

### Output:

```
10000
```

---

# **17. Protected Members**

**Protected members** are attributes/methods with a **single underscore** prefix (`_name`). They're meant for internal use within the **class and its subclasses**.

### Code:

```python
class Person:
    def __init__(self, name, age, _id):
        self.name = name
        self.age = age
        self._id = _id

class Student(Person):
    def __init__(self, name, age, _id, marks):
        super().__init__(name, age, _id)
        self.marks = marks

stu = Student("Maryam", 20, "STU123", 95)
print(stu._id)
```

### Output:

```
STU123
```

---

# **18. Inheritance Overview**

Inheritance models an *is-a* relationship, allowing a class (child/derived) to reuse and extend functionality from another (parent/base). A child class inherits fields/methods from parent class.

Benefits:

* Reuse
* Modularity
* Maintainability

---

# **19. Single Inheritance**

Single inheritance: a subclass inherits from **exactly one parent**. It’s straightforward and eliminates ambiguity. Subclass can use, extend, or override parent's methods and attributes.

<img width="258" height="299" alt="image" src="https://github.com/user-attachments/assets/cd85f5ee-cde6-400f-920f-c1af3aa4a8d6" />

### Code:

```python
class Parent:
    def func1(self):
        print("this is function one")

class Child(Parent):
    def func2(self):
        print("this is function two")

ob = Child()
ob.func1()
ob.func2()
```

### Output:

```
this is function one
this is function two
```

---

# **20. Multiple Inheritance**

Multiple inheritance allows a class to inherit from **more than one parent class**. The child class gets attributes and methods from all parent classes. It allows combining capabilities from separate classes. 

<img width="402" height="256" alt="image" src="https://github.com/user-attachments/assets/ab7e71c0-b947-4394-9635-7a978525ca6a" />

When multiple parent classes have methods or attributes with the same name, Python uses the **Method Resolution Order (MRO)** to **determine which one gets called**. **Basic rule of MRO**:

1. Current class first
2. Then parent classes from **left to right**
3. Then grandparent classes following the same rule

### Code:

```python
class Parent1:
    def func1(self):
        print("function 1")

class Parent2:
    def func2(self):
        print("function 2")

class Child(Parent1, Parent2):
    def func3(self):
        print("function 3")

ob = Child()
ob.func1()
ob.func2()
ob.func3()
```

### Output:

```
function 1
function 2
function 3
```

---

# **21. Multilevel Inheritance**

Multilevel inheritance builds a chain: class C inherits from B, which inherits from A. Be mindful of complexity: deep inheritance chains make reasoning and maintenance harder.

<img width="286" height="276" alt="image" src="https://github.com/user-attachments/assets/e553a534-cfcf-4ae0-b5cc-5413828ed22d" />


### Code:

```python
class A:
    def showA(self):
        print("A")

class B(A):
    def showB(self):
        print("B")

class C(B):
    def showC(self):
        print("C")

c = C()
c.showA()
c.showB()
c.showC()
```

### Output:

```
A
B
C
```

---

# **22. Hierarchical Inheritance**

Hierarchical inheritance: multiple child classes inherit from a single parent. Useful when different specializations share a common base implementation.

<img width="360" height="225" alt="image" src="https://github.com/user-attachments/assets/b492f6b2-9519-4623-8dff-4537af0ea966" />

### Code:

```python
class Parent:
    def func1(self):
        print("function 1")

class Child1(Parent):
    def func2(self):
        print("function 2")

class Child2(Parent):
    def func3(self):
        print("function 3")

c1 = Child1()
c2 = Child2()
c1.func1()
c1.func2()
c2.func1()
c2.func3()
```

### Output:

```
function 1
function 2
function 1
function 3
```

---

# **23. Hybrid Inheritance**

Hybrid inheritance mixes several kinds (**single, multiple, multilevel**). It can implement flexible architectures but increases complexity and MRO considerations. Use it only when necessary and document class relationships clearly.

<img width="189" height="315" alt="image" src="https://github.com/user-attachments/assets/462bfac1-8d43-4ea8-9c2a-4adb295ae86e" />

### Code:

```python
class A:
    def showA(self):
        print("A")

class B(A):
    def showB(self):
        print("B")

class C(A):
    def showC(self):
        print("C")

class D(B, C):
    def showD(self):
        print("D")

d = D()
d.showA()
d.showB()
d.showC()
d.showD()
```

### Output:

```
A
B
C
D
```

---

# **24. The super() Function**

The `super()` function returns a temporary object of the superclass that allows you to call its methods. It's used to access inherited methods that have been overridden in a class.

### Example 1:

```python
class Person:
    def __init__(self, name, id):
        self.name = name
        self.id = id

class Emp(Person):
    def __init__(self, name, id):
        super().__init__(name, id)
        self.role = "Employee"

e = Emp("David", 103)
print(e.name, e.id, e.role)
```

### Output:

```
David 103 Employee
```

### Example 2

```python
class Parent:
    def __init__(self, name):
        self.name = name
        print("Parent initialized")
    
    def greet(self):
        return (f"Hello, I'm {self.name}")

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)  # Call Parent's __init__
        self.age = age
        print("Child initialized")
    
    def greet(self):
        parent_greeting = super().greet()  # Call Parent's greet method
        return (f"{parent_greeting} and I'm {self.age} years old")

child = Child("Alice", 10)
print(child.greet())

```

**Output**

```
Parent initialized
Child initialized
Hello, I'm Alice and I'm 10 years old
```

---

# **25. Method Overriding (polymorphism)**

**Method overriding** allows a subclass to provide a **new implementation for a method defined in the parent**. When an overridden method is called on a subclass instance, the subclass version runs. **Overriding enables polymorphism**: code can call the base method and various subclasses will behave differently.

### Code:

```python
class Parent:
    def show(self):
        print("Parent")

class Child(Parent):
    def show(self):
        print("Child")

p = Parent()
c = Child()
p.show()
c.show()
```

### Output:

```
Parent
Child
```

---

# **26. Operator Overloading**

Operator overloading allows you to define how operators (like `+`, `-`, `*`, etc.) work with your custom classes. This makes your objects behave like built-in types. Python calls special methods (**double underscore methods**) when operators are used. By defining these methods, you can customize operator behavior.

### Code:

```python
class Number:
    def __init__(self, n):
        self.n = n

    def __add__(self, other):  # Overload +
        return self.n + other.n

a = Number(5)
b = Number(10)
print(a + b)
```

### Output:

```
15
```

---

# **27. Packages in Python**

A package is a way to **organize related modules into a single directory hierarchy**. Packages help structure Python's module namespace using dotted notation. What is a Package?
* A directory containing Python modules
* Must contain a special `__init__.py` file
* Can contain sub-packages (nested directories)
* Allows hierarchical organization of code

**Creating a Basic Package**: For example we want to create a complete package (`my_package`) with `login.py` and `logout.py` modules.

```
my_package/
│   __init__.py
│   module1.py
│   module2.py
```

### Example modules:

**my_package/`login.py`**

```python
def do_login():
    print("logging in ...")
```

**my_package/`logout.py`**

```python
def do_logout():
    print("logging out ...")
```

**my_package/`__init__.py`**

```python
from .login import do_login
from .logout import do_logout
```

### Using Your Package
**app.py**

#### Method 1: Import Entire Package
```python
import my_package
my_package.do_login()
my_package.do_logout()
```
#### Output:

```
logging in ...
logging out ...
```

#### Method 2: Import Specific Modules

```python
from my_package import do_login, do_logout

do_login()
do_logout()
```

#### output

```
logging in ...
logging out ...
```
---

# **28. Summary Table of Methods**

| Method                    | Short Description                          | Example                                 |
| ------------------------- | ------------------------------------------ | --------------------------------------- |
| `__init__()`              | Constructor initializes object attributes  | `def __init__(self,r): self.r=r`        |
| `__del__()`               | Destructor executed when object is deleted | `def __del__(self): print("destroyed")` |
| `__str__()`               | Returns string representation              | `print(obj)`                            |
| Static Methods            | Methods without `self`                     | `@staticmethod`                         |
| Private Attribute (`__x`) | Hidden from outside                        | `self.__balance`                        |
| Getter                    | Reads private attribute                    | `get_age()`                             |
| Setter                    | Writes private attribute                   | `set_age()`                             |
| Name Mangling             | Access private: `_Class__attr`             | `_Employee__salary`                     |
| Inheritance               | Child inherits parent class                | `class B(A):`                           |
| Multiple Inheritance      | Inherit from multiple parents              | `class C(A,B)`                          |
| super()                   | Calls parent class method                  | `super().__init__()`                    |
| Method Overriding         | Redefining parent method                   | `def show(self):`                       |
| Operator Overloading      | Redefining operators                       | `def __add__(...)`                      |

---

