# **1. Introduction to Object-Oriented Programming in Python**
This section explains the concept of **object-oriented programming (OOP)** and how Python supports it. Object-Oriented Programming (OOP) models real-world objects such as animals, cars, users, bank accounts, etc.

Python is considered an object-oriented programming language because everything is treated as an **object** (integers, strings, lists, tuples, sets, functions, classes). Advantages of OOP:

* Better organization of code
* Encapsulation
* Reusability
* Ability to group attributes and behavior together

---

# **2. Objects in Python**

**Description:**
An object is a concrete **instance of a class**. Objects have:

* **Properties (Attributes - state):** Data such as color, weight, size
* **Methods (Behaviors):** Operations such as walk(), fly(), deposit(), etc.

Example (conceptual):

* Object name: *bird*
* Attributes: *color, weight*
* Behavior: *Walking, flying, drinking, eating*

You can check the type of any object using `type()`. Also, `isinstance()` checks membership in a class hierarchy.
* `type(x)`: returns the class/type of `x`.
* `isinstance(obj, Class)` â€” returns `True` if `obj` is instance of `Class` or its `subclasses`.

---

# **3. Classes in Python**

**Description:**
A class is a blueprint for objects: it **declares attributes (data fields) and methods (operations)**. Classes **group related data and behavior**, making code modular and easier to reason about.

**Example (conceptual):**

* Class: Car
* Properties: Doors, wheels, color
* Methods: Start, stop, brake

**A class describes:**

* Attributes (data members)
* Methods (behaviors)
* Constructor, destructor
* Static/dynamic features

---

# **4. Defining Classes**

Use `class` followed by a capitalized identifier. Provide a docstring for clarity. Inside the class you declare attributes and methods.

### Example: Basic Class Definition

```python
class MyClass:
    """This is a simple class"""
```

---

# **5. Instantiating Classes**

Creating an object (instantiation) **runs the** `__init__` **constructor** and **returns an instance** you can use.

### Example: Creating an Instance

```python
class Shape:
    shape1 = "Circle"
    Pi = 3.14

shp = Shape()
print(shp.shape1)
```

### **Output**

```
Circle
```

---

# **6. Accessing Class Members**

How to access attributes inside and outside a class.

* Outside (instance property access): `obj.attribute`
* Outside (static attribute - class-level access): `ClassName.attribute`
* Inside class: `self.attribute`

---

# **7. Fields and Methods (Attributes and Behaviors)**

* **Fields (attributes):** store object data; can be public, protected, or private by naming convention.
* **Methods**: functions defined in the `class`; **first parameter is** `self` (the instance).

---

# **8. Example: Circle Class**

Shows basic class with methods and `__str__`. The `__str__` is for printable representation and should return a human-readable string.

### Code:

```python
import math

class Circle:
    pi = math.pi
    r = 0

    def Area(self):     # Returns area of circle
        return self.pi * self.r ** 2

    def Perime(self):   # Returns perimeter of circle
        return 2 * self.pi * self.r

    def __str__(self):  # Converts object to string
        s = "R is:" + str(self.r)
        s += " Area is:" + str(self.Area())
        s += " Perime is:" + str(self.Perime())
        return s

c = Circle()
c.r = 3
print(c)
```

### Output:

```
R is:3 Area is:28.274333882308138 Perime is:18.84955592153876
```

---

# **9. Constructor (**init**)**

**Description:**
Initializes object attributes when object is created.

### Code:

```python
class Circle:
    pi = 3.14

    def __init__(self, r):   # Constructor: initializes radius
        self.r = r

    def Area(self):
        return self.pi * self.r ** 2
```

### Example:

```python
c = Circle(5)
print(c.Area())
```

### Output:

```
78.5
```

---

# **10. Destructor (**del**)**

The destructor is a special method that **gets called when an object is about to be destroyed**. It's used for cleanup operations before the object is removed from memory.

### Code:

```python
class Test:
    def __del__(self):   # Destructor: runs on delete
        print("Object destroyed")

obj = Test()
del obj
```

### Output:

```
Object destroyed
```

---

# **11. Dynamic vs Static Methods**

**Description:**

* **Static method**: Methods that don't have access to the instance or class. Does not use `self`. Behave like regular functions but belong to the class namespace.
* **Dynamic method**: Regular methods that belong to object instances. Uses `self`.

### Code:

```python
class Person:

    @staticmethod
    def display():       # Static method: prints welcome
        print("Welcome!!")

    @staticmethod
    def func1(n):        # Static method: prints square
        print(n * n)

Person.display()
Person.func1(5)
```

### Output:

```
Welcome!!
25
```

---

# **12. Encapsulation**

Encapsulation restricts direct access to attributes and methods.

**Types of access**:

* **Public**: Accessible from anywhere, default in Python, and No special syntax.
* **Private** (`__name`): Accessible only within the class, and name mangling with **double underscore prefix**.
* **Protected** (`_name`): Accessible within the class and its subclasses and  name mangling with with **single underscore prefix**.

---

# **13. Public Members**

### Code:

```python
class Employee:
    def __init__(self, name, age):
        self.name = name      # Public
        self.age = age        # Public

    def display(self):
        print("Employee Name:", self.name)
        print("Employee Age:", self.age)

s = Employee("Ali", 20)
s.display()
```

### Output:

```
Employee Name: Ali
Employee Age: 20
```

---

# **14. Private Members**

**Description:**
Private attributes are accessed only inside the class.

### Code:

```python
class BankAccount:
    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance  # Private

    def deposit(self, amount):
        self.__balance += amount
        print("New balance:", self.__balance)

acc = BankAccount("John", 1000)
acc.deposit(500)
```

### Output:

```
New balance: 1500
```

---

# **15. Getters and Setters**

**Description:**
Allows controlled read/write access to private attributes.

### Code:

```python
class Student:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def get_name(self):     # Getter
        return self.__name

    def set_name(self, name):  # Setter
        self.__name = name

student = Student("Alice", 20)
print(student.get_name())
student.set_name("Bob")
print(student.get_name())
```

### Output:

```
Alice
Bob
```

---

# **16. Name Mangling**

### Code:

```python
class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.__salary = salary

emp = Employee("Jessa", 10000)
print(emp._Employee__salary)   # Mangled access
```

### Output:

```
10000
```

---

# **17. Protected Members**

### Code:

```python
class Person:
    def __init__(self, name, age, _id):
        self.name = name
        self.age = age
        self._id = _id

class Student(Person):
    def __init__(self, name, age, _id, marks):
        super().__init__(name, age, _id)
        self.marks = marks

stu = Student("Maryam", 20, "STU123", 95)
print(stu._id)
```

### Output:

```
STU123
```

---

# **18. Inheritance Overview**

**Description:**
A child class inherits fields/methods from parent class.

Benefits:

* Reuse
* Modularity
* Maintainability

---

# **19. Single Inheritance**

### Code:

```python
class Parent:
    def func1(self):
        print("this is function one")

class Child(Parent):
    def func2(self):
        print("this is function two")

ob = Child()
ob.func1()
ob.func2()
```

### Output:

```
this is function one
this is function two
```

---

# **20. Multiple Inheritance**

### Code:

```python
class Parent1:
    def func1(self):
        print("function 1")

class Parent2:
    def func2(self):
        print("function 2")

class Child(Parent1, Parent2):
    def func3(self):
        print("function 3")

ob = Child()
ob.func1()
ob.func2()
ob.func3()
```

### Output:

```
function 1
function 2
function 3
```

---

# **21. Multilevel Inheritance**

### Code:

```python
class A:
    def showA(self):
        print("A")

class B(A):
    def showB(self):
        print("B")

class C(B):
    def showC(self):
        print("C")

c = C()
c.showA()
c.showB()
c.showC()
```

### Output:

```
A
B
C
```

---

# **22. Hierarchical Inheritance**

### Code:

```python
class Parent:
    def func1(self):
        print("function 1")

class Child1(Parent):
    def func2(self):
        print("function 2")

class Child2(Parent):
    def func3(self):
        print("function 3")

c1 = Child1()
c2 = Child2()
c1.func1()
c1.func2()
c2.func1()
c2.func3()
```

### Output:

```
function 1
function 2
function 1
function 3
```

---

# **23. Hybrid Inheritance**

### Code:

```python
class A:
    def showA(self):
        print("A")

class B(A):
    def showB(self):
        print("B")

class C(A):
    def showC(self):
        print("C")

class D(B, C):
    def showD(self):
        print("D")

d = D()
d.showA()
d.showB()
d.showC()
d.showD()
```

### Output:

```
A
B
C
D
```

---

# **24. The super() Function**

### Code:

```python
class Person:
    def __init__(self, name, id):
        self.name = name
        self.id = id

class Emp(Person):
    def __init__(self, name, id):
        super().__init__(name, id)
        self.role = "Employee"

e = Emp("David", 103)
print(e.name, e.id, e.role)
```

### Output:

```
David 103 Employee
```

---

# **25. Method Overriding**

### Code:

```python
class Parent:
    def show(self):
        print("Parent")

class Child(Parent):
    def show(self):
        print("Child")

p = Parent()
c = Child()
p.show()
c.show()
```

### Output:

```
Parent
Child
```

---

# **26. Operator Overloading**

### Code:

```python
class Number:
    def __init__(self, n):
        self.n = n

    def __add__(self, other):  # Overload +
        return self.n + other.n

a = Number(5)
b = Number(10)
print(a + b)
```

### Output:

```
15
```

---

# **27. Packages in Python**

**Description:**
Packages allow organizing modules.

Example modules:

**login.py**

```python
def do_login():
    print("logging in ...")
```

**logout.py**

```python
def do_logout():
    print("logging out ...")
```

****init**.py**

```python
from .login import do_login
from .logout import do_logout
```

**app.py**

```python
from auth import do_login, do_logout
do_login()
do_logout()
```

### Output:

```
logging in ...
logging out ...
```

---

# **28. Summary Table of Methods**

| Method                    | Short Description                          | Example                                 |
| ------------------------- | ------------------------------------------ | --------------------------------------- |
| `__init__()`              | Constructor initializes object attributes  | `def __init__(self,r): self.r=r`        |
| `__del__()`               | Destructor executed when object is deleted | `def __del__(self): print("destroyed")` |
| `__str__()`               | Returns string representation              | `print(obj)`                            |
| Static Methods            | Methods without `self`                     | `@staticmethod`                         |
| Private Attribute (`__x`) | Hidden from outside                        | `self.__balance`                        |
| Getter                    | Reads private attribute                    | `get_age()`                             |
| Setter                    | Writes private attribute                   | `set_age()`                             |
| Name Mangling             | Access private: `_Class__attr`             | `_Employee__salary`                     |
| Inheritance               | Child inherits parent class                | `class B(A):`                           |
| Multiple Inheritance      | Inherit from multiple parents              | `class C(A,B)`                          |
| super()                   | Calls parent class method                  | `super().__init__()`                    |
| Method Overriding         | Redefining parent method                   | `def show(self):`                       |
| Operator Overloading      | Redefining operators                       | `def __add__(...)`                      |

---

